\begin{frame}
  \titlepage
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Me}
  \begin{itemize}
    \pause
    \item<+-> Started out in music
    \item<+-> Found PHP around 2011, then saved by FP soon after
    \item<+-> Programming languages and compilers in free time
    \item<+-> Worked on the Oden language last year
    \item<+-> Currently building CodeScene at work, mostly in Clojure
    \item<+-> Building Hyper in free time
  \end{itemize}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Agenda}
  \begin{itemize}
    \pause
    \item<+-> Functional Programming, Type Systems, and Web Applications
    \item<+-> What about Server-Side Rendering?
    \item<+-> Web Servers, Functional Programming, and Static Typing
    \item<+-> Hyper
  \end{itemize}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \singletitle{Functional Programming, Type Systems, and Web Applications}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Single-Page Applications}
  \begin{itemize}
    \pause
    \item<+-> Work more like desktop applications
    \item<+-> There are \textbf{a lot} of these frameworks in JS
    \item<+-> Angular, Ember, Meteor, React (with friends)
    \item<+-> Without Javascript, you get nothing
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Functional Programming Influence}
  \begin{itemize}
    \pause
    \item<+-> FP influences Javascript
    \item<+-> ECMAScript 6 has higher-order functions, arrow function syntax
    \item<+-> Libraries like Underscore, Rambda, Fantasy Land
    \item<+-> React is functional at its core
    \item<+-> Functional Reactive Programming (FRP)
    \item<+-> Javascript as a compile target for FP languages
    \item<+-> Still, main focus is single-page apps
  \end{itemize}
\end{frame}

\begin{frame}
  \singletitle{What about Server-Side Rendering?}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Server-Side Rendering}
  \begin{itemize}
    \pause
    \item<+-> Progressive Enhancement
    \item<+-> Using what's already in the browser
    \item<+-> The client-server state machine, and "isomorphic" web apps
    \item<+-> PJAX
    \item<+-> If it's a tooling problem, let's build tools!
  \end{itemize}
\end{frame}

\begin{frame}
  \singletitle{Web Servers, Functional Programming, and Static Typing}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Web Servers, Functional Programming, and Static Typing}
  \begin{itemize}
    \pause
    \item<+-> Dynamic languages in web server programming
    \item<+-> Compile-time guarantees
    \item<+-> Safely abstract and compose
    \item<+-> Maintainable code
    \item<+-> Developer experience, incentivize not doing SPA
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Things I've Found}
  \begin{itemize}
    \pause
    \item<+-> Haskell:
      \begin{itemize}
        \item<+-> Happstack
        \item<+-> Yesod
        \item<+-> Servant
      \end{itemize}
    \item<+-> Scala:
      \begin{itemize}
        \item<+-> Play
        \item<+-> Lift
        \item<+-> Rho
      \end{itemize}
    \item<+-> PureScript:
      \begin{itemize}
        \item<+-> purescript-express
      \end{itemize}
  \end{itemize}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Statically Typed Middleware}
  \begin{itemize}
    \pause
    \item<+-> Middleware is a common abstraction
    \item<+-> Very easy to mess up if dynamically typed
      \begin{itemize}
        \item<+-> Incorrect ordering
        \item<+-> Incomplete responses
        \item<+-> Overwriting headers
        \item<+-> Writing multiple responses
        \item<+-> Consuming non-parsed, or badly parsed, request body
        \item<+-> Missing authentication and/or authorization
      \end{itemize}
    \item<+-> Idea: use extensible records in PureScript!
  \end{itemize}
\end{frame}


%
% HYPER
%


\begin{frame}
  \begin{center}
    \vfill\vfill
    \includegraphics[width=0.5\textwidth]{src/graphics/hyper.png}\\
    \vspace{1em}
    \fontsize{20pt}{20pt}{Type-safe, statically checked composition of HTTP servers}
    \vfill\vfill
  \end{center}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Goals}
  \begin{itemize}
    \pause
    \item<+-> A safe HTTP middleware architecture
    \item<+-> Make the effects of applying middleware explicit in types
    \item<+-> Ensure correct composition of middleware and application components
    \item<+-> Interoperability with NodeJS and other backends (purerl, purescript-native)
    \item<+-> No magic
  \end{itemize}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{How?}
  \begin{itemize}
    \pause
    \item<+-> Track middleware effects in type system (not only side-effects!)
    \item<+-> Leverage extensible records in PureScript
    \item<+-> Provide a common API for middleware
    \item<+-> Write backend-agnostic middleware where possible
    \item<+-> Integrate with existing NodeJS libraries
  \end{itemize}
\end{frame}

\begin{frame}
  \singletitle{Design}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Conn}
  \lstinputlisting[language=purescript]{src/listings/Conn.purs}
  \notelist{
  \item Conn, short for Connection
  \item Models the entirety of an HTTP connection
  \item Design adapted from Plug in Elixir
    }
\end{frame}


\begin{frame}
  \frametitle{Middleware (Old Design)}
  \lstinputlisting[language=purescript]{src/listings/MiddlewareOld.purs}
  \notelist{
  \item A function transformed a Conn to another Conn, in some type \textit{m}
  \item A type synonym for a regular function
  \item The \textit{m} could be any Applicative or Monad
  \item This signature might remind you of Bind
    }
\end{frame}

\begin{frame}
  \frametitle{Middleware (Old Design)}
  \lstinputlisting[language=purescript]{src/listings/Kleisli.purs}
  \notelist{
  \item Middleware could therefore be composed using regular Kleisli composition
  \item Here we see three middleware, composed from left to right
    }
\end{frame}

\begin{frame}
  \frametitle{Whoops, Not Safe}
  \lstinputlisting[language=purescript]{src/listings/MiddlewareOldUnsafe.purs}
  \notelist{
  \item We define a middleware called \textit{badMiddleware}
  \item It takes a conn and passes it to the first respond middleware
  \item It ignores that resulting conn, passes the argument again
  \item Had we passed the result, or used Kleisli, we would have a type error
  \item The problem: Our safety is in the Conn values, and we can discard them
  \item The solution: The monad has to carry the Conn type
    }
\end{frame}

\begin{frame}
  \frametitle{Middleware (Revised)}
  \lstinputlisting[language=purescript]{src/listings/Middleware.purs}
  \notelist{
  \item The new middleware is an indexed monad
  \item Works as a state monad, with state type changes in its parameters
  \item You cannot run an effectful middleware without the types matching
  \item Let's see how this solves the double-end problem from before
    }
\end{frame}

\begin{frame}
  \frametitle{Response State Transitions}
  \begin{itemize}
    \pause
    \item<+-> Hyper tracks the state of response writing
    \item<+-> Guarantees correctness in response handling, preventing common programming errors
    \item<+-> Abstractions can be built on top safely
    \item<+-> Response-writing middleware can be backend-agnostic
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{ResponseStateTransition}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/ResponseStateTransition.purs}
  \notelist{
  \item We start by looking at this helper type alias
  \item A transition is a Middleware
  \item Takes Conn with Response writer in the \textbf{from} state
  \item Returns Conn with Response writer in the \textbf{to} state
    }
\end{frame}

\begin{frame}[fragile]
  \frametitle{ResponseWriter}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/ResponseWriter.purs}
  \notelist{
  \item ResponseWriter encodes the possible state transitions
    }
\end{frame}

\begin{frame}
  \frametitle{Writing Headers}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/headers.purs}
  \notelist{
  \item The \textit{headers} function is a minimal example of abstraction
  \item It writes all specified headers, then closes headers
  \item The implementation? Pretty simple.
    }
\end{frame}

\begin{frame}
  \frametitle{Writing a Response}
  \lstinputlisting[language=purescript]{src/listings/Response.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Writing a Response}
  \lstinputlisting[language=purescript,style=medium-size,firstline=1,lastline=8]{src/listings/respond.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Writing a Response}
  \lstinputlisting[language=purescript,firstline=9]{src/listings/respond.purs}
  \notelist{
  \item The implementation is quite simple.
    }
\end{frame}

\begin{frame}
  \frametitle{Parsing the Request Body}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/readBodyAsString.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Parsing the Request Body}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/readBody.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \singletitle{Form Parsing}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Form Parsing}
  \lstinputlisting[language=purescript,firstline=1,lastline=15,style=medium-size]{src/listings/parseForm.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Form Parsing}
  \lstinputlisting[language=purescript,firstline=16,style=smaller-size]{src/listings/parseForm.purs}
  \notelist{
  \item Hej hopp
    }
\end{frame}

\begin{frame}
  \singletitle{Example (Form Parsing)}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Example (Form Parsing)}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/example-renderNameForm.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Example (Form Parsing)}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/example-htmlWithStatus.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Example (Form Parsing)}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/example-form-handler.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Example (Form Parsing)}
  \lstinputlisting[language=purescript,style=smaller-size]{src/listings/example-form-handlePost.purs}
  \notelist{
  \item TODO
    }
\end{frame}


\begin{frame}
  \frametitle{Example (Form Parsing)}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/example-form-app.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \singletitle{Demo}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \singletitle{Example (Type-Safe Routing)}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Example (Type-Safe Routing)}
  \lstinputlisting[language=purescript,style=smaller-size]{src/listings/example-routing-about.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Example (Type-Safe Routing)}
  \lstinputlisting[language=purescript,style=smaller-size]{src/listings/example-routing-home.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Example (Type-Safe Routing)}
  \lstinputlisting[language=purescript,style=smaller-size]{src/listings/example-routing-app.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \singletitle{Demo}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \singletitle{Next Up}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Next Up}
  \begin{itemize}
    \item Routed resources should be encoded in Conn types
    \item Cross-routing is tricky, requires annotations
    \item All the WEB SCALE stuff
  \end{itemize}
\end{frame}

\begin{frame}
  \singletitle{Thank You}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \titlepage
  \notelist{
  \item TODO
    }
\end{frame}
