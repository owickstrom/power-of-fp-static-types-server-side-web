\begin{frame}
  \titlepage
  \notelist{
  \item Welcome to my talk with a very long title
	\item The Power of Functional Programming and Static Type Systems in Server-Side Web Applications
    }
\end{frame}

\begin{frame}
  \frametitle{Me}
  \begin{itemize}
    \pause
    \item<+-> I live and work in Malm\"{o}, Sweden
    \item<+-> Started out in music
    \item<+-> Found PHP around 2011, then saved by FP soon after
    \item<+-> Worked on the Oden language last year
    \item<+-> Currently building CodeScene at work, mostly in Clojure
    \item<+-> Building Hyper in free time
  \end{itemize}
  \notelist{
  \item Let me introduce myself
  \item I live and work in Malmo in Sweden
  \item I started out in music
  \item Wrote my first band site in PHP
  \item Luckily I was saved by functional programming not long after
  \item Worked on Oden
  \item I am currently working on CodeScene, mostly in Clojure
  }
\end{frame}

\begin{frame}
  \frametitle{Agenda}
  \begin{itemize}
    \pause
    \item<+-> Overview: Functional Programming and Web Applications
    \item<+-> What about Server-Side Rendering?
    \item<+-> Static Typing for Server-Side Web
    \item<+-> Hyper
			\begin{itemize}
				\item<+-> Design
				\item<+-> Type-Level Routing
				\item<+-> XHR Clients
				\item<+-> Future Work
			\end{itemize}
  \end{itemize}
  \notelist{
  \item Let me go through what I'll cover today
  \item First: general overview of ...
  \item Then look closer at server-side rendering
  \item and some examples of static typing for server-side web, next level
	\item then we will dive into Hyper
    \begin{itemize}
      \item<+-> Design
      \item<+-> Type-Level Routing
      \item<+-> XHR Clients
      \item<+-> Future Work
    \end{itemize}
  }
\end{frame}

\begin{frame}
  \singletitle{Overview: Functional Programming and Web Applications}
  \notelist{
  \item Let's get going
  }
\end{frame}

\begin{frame}
  \frametitle{Functional Programming Influence}
  \begin{itemize}
    \pause
    \item<+-> FP influences Javascript
    \item<+-> ECMAScript 6 has higher-order functions, arrow function syntax
    \item<+-> Libraries like Underscore, Rambda, Fantasy Land
    \item<+-> React is functional at its core
    \item<+-> Functional Reactive Programming (FRP)
    \item<+-> Javascript as a compile target for FP languages
    \item<+-> Still, main focus is single-page apps
  \end{itemize}
  \notelist{
  \item Functional programming influences Javascript
  \item ECMAScript
	\item Underscore, Rambda, Fantasy Land
	\item React is functional ...
	\item FRP has made its way into ...
  \item Still, main focus of efforts...
  }
\end{frame}

\begin{frame}
  \frametitle{Single-Page Applications}
  \begin{itemize}
    \pause
    \item<+-> Work more like desktop applications
    \item<+-> There are \textbf{a lot} of these frameworks in JS
    \item<+-> Angular, Ember, Meteor, React (with friends)
    \item<+-> Without Javascript, you get nothing
  \end{itemize}
  \notelist{
  \item Single page apps work more like traditional desktop apps
  \item Lot of JS frameworks, many just minor flavours of previous ones
	\item Some of the big ones are...
  \item And usually, without Javascript execution, you get nothing (last bullet)
	\item Does this matter? Yes.
  \item Disabled, flaky network, low-budget devices
  }
\end{frame}

\begin{frame}
  \singletitle{What about Server-Side Rendering?}
  \notelist{
  \item What about ...
  \item Do we need to make a binary choice?
  \item No. One approach is Progressive Enhancement...
  }
\end{frame}

\begin{frame}
  \singletitle{Progressive Enhancement}
  \notelist{
  \item Progressive enhancement is about defining the lower bound of support
  \item Then gradually make things nicer for more capable clients
	\item Everyone above that threshold gets something, even if it's rough
  }
\end{frame}

\begin{frame}
  \singletitle{80/20}
  \notelist{
  \item Let's say all of your code and functionality is not equally important
  \item A smaller part provides the core value of your business
  \item You have lots of supporting code as well
	\item Login forms, settings pages, payment, integrations, documentation
  \item How much of the pages you visit online really needs Javascript to work?
	\item I would claim most would work fine with links and forms
	\item Let's write client-side code where it provides value
  \item Unless you enjoy reinventing the web browser over and over
  }
\end{frame}

\begin{frame}
  \frametitle{``Isomorphic'' Web Applications}
  \begin{itemize}
		\pause
    \item<+-> Goal: one framework that runs on both client and server
		\item<+-> ``Free progressive enhancements''
    \item<+-> The client and server state machines
    \item<+-> Are we really talking about initial rendering?
  \end{itemize}
  \notelist{
	\item I want to mention the hype around \textit{isomorphic} web apps
  \item Goal:...
  
  \item One executes in the browser locally
  \item The other transfers state over the network through links and forms
  \item Are we really talking about initial rendering ...?
  }
\end{frame}

\begin{frame}
  \frametitle{PJAX}
  \begin{itemize}
    \pause
    \item<+-> Hooks in on link and form events
    \item<+-> Requests pages over XHR with special header
    \item<+-> Server responds with only inner content
    \item<+-> PJAX swaps the inner content on the client
  \end{itemize}
  \notelist{
  \item A nice approach that we use for CodeScene is PJAX...
  \item It progressively enhances a server-side app with low effort
  \item \textit{explain steps...}
  \item Maybe this is a bit rough...
  }
\end{frame}

\begin{frame}
  \singletitle{If server-side web has tooling problems, let's build nice tools!}
  \notelist{
  \item I do not know if this is the case...
  \item Let's use good languages and make use of ... (change slide)
  }
\end{frame}

\begin{frame}
  \singletitle{Static Typing for Server-Side Web}
  \notelist{
  \item Static typing for server-side web
  }
\end{frame}

\begin{frame}
  \frametitle{Static Typing for Server-Side Web}
  \begin{itemize}
    \pause
    \item<+-> Dynamic languages in web server programming
    \item<+-> Compile-time guarantees
    \item<+-> Safely abstract and compose
    \item<+-> Maintainable code
    \item<+-> Developer experience
  \end{itemize}
  \notelist{
  \item We have seen a lot of dynamically typed languages in web development
  \item When programs grow big, and teams grow big, static typing is our friend
  \item We should be able to safely build abstractions and compose things
  \item Be confident that the pieces work together
	\item We should be able to maintain code, refactor it, change it, delete it
  \item Again, I think we need a good developer experience
	\item Not only making stuff shiny, but by using solid theory and research
  }
\end{frame}

\begin{frame}
  \frametitle{Things I've Found}
  \begin{itemize}
    \pause
    \item<+-> Haskell:
      \begin{itemize}
        \item<+-> Yesod
        \item<+-> Servant
      \end{itemize}
    \item<+-> Scala:
      \begin{itemize}
        \item<+-> Play
        \item<+-> Rho
      \end{itemize}
    \item<+-> PureScript:
      \begin{itemize}
        \item<+-> purescript-express
        \item<+-> purescript-rest
      \end{itemize}
  \end{itemize}
  \notelist{
  \item There are some things out there
  \item For Haskell, two alternatives are ...
  \item Not that I know much about Scala, but I found these...
  \item And, as we are going to talk about PureScript, I want to mention...
  }
\end{frame}

\begin{frame}
  \frametitle{Statically Typed Middleware}
  \begin{itemize}
    \pause
    \item<+-> Middleware is a common abstraction
    \item<+-> Very easy to mess up if dynamically typed
      \begin{itemize}
        \item<+-> Incorrect ordering
        \item<+-> Corrupt or incomplete responses
        \item<+-> Conflicting writes
        \item<+-> Incorrect error handling
        \item<+-> Consuming non-parsed, or badly parsed, request body
        \item<+-> Missing authentication and/or authorization
      \end{itemize}
    \item<+-> Idea: use extensible records in PureScript!
  \end{itemize}
  \notelist{
  \item Looking at other frameworks, like connect and Plug...
  \item In Java Servlets it's called filters
  \item It is very easy to mess up. You can get... (up to missing auth)
  \item After a talk by Edwin Brady on Idris and session types, I got this idea...
  \item How about using extensible records ...
  }
\end{frame}


%
% HYPER
%


\begin{frame}
  \begin{center}
    \vfill\vfill
    \includegraphics[width=0.5\textwidth]{src/graphics/hyper.png}\\
    \vspace{1em}
    \fontsize{20pt}{20pt}{Type-safe, statically checked composition of HTTP servers}
    \vfill\vfill
  \end{center}
  \notelist{
  \item And that's where Hyper started
  }
\end{frame}

\begin{frame}
  \frametitle{Goals}
  \begin{itemize}
    \pause
    \item<+-> A safe HTTP middleware architecture
    \item<+-> Make the effects of applying middleware explicit in types
    \item<+-> Ensure correct composition of middleware and application components
    \item<+-> Interoperability with NodeJS and other backends (purerl, purescript-native)
    \item<+-> No magic
  \end{itemize}
  \notelist{
  \item The goals are...
  \item A safe HTTP middleware architecture
  \item Make the effects of applying middleware explicit in types
  \item Ensure correct composition
  \item Interoperability with NodeJS and other backends
  \item Different web servers, Erlang backend, purescript-native
  \item Also: no magic. No preprocessing or code generation.
  }
\end{frame}

\begin{frame}
  \frametitle{How?}
  \begin{itemize}
    \pause
    \item<+-> Track middleware effects in type system, pure transformations and side effects
    \item<+-> Leverage extensible records in PureScript
    \item<+-> Provide a common API for middleware
    \item<+-> Write backend-agnostic middleware where possible
    \item<+-> Integrate with existing NodeJS libraries
  \end{itemize}
  \notelist{
  \item Track middleware effects in type system...
  \item Leverage extensible records in PureScript
  \item Provide a common API for middleware
  \item Write backend-agnostic middleware
  \item Integrate with existing NodeJS libraries
  }
\end{frame}

\begin{frame}
  \singletitle{Design}
  \notelist{
  \item I will go through the core design first
  }
\end{frame}

\begin{frame}
  \frametitle{Conn}
  \lstinputlisting[language=purescript]{src/listings/Conn.purs}
  \notelist{
  \item Conn, short for Connection
  \item Models the entirety of an HTTP connection
  \item Design adapted from Plug in Elixir
  \item It has a request and response, maybe not surprising
  \item But also components, which is an extension point for middleware
  \item I'm not so sure about components yet, it may go away
    }
\end{frame}


\begin{frame}
  \frametitle{Middleware (Old Design)}
  \lstinputlisting[language=purescript]{src/listings/MiddlewareOld.purs}
  \notelist{
  \item A function transformed a Conn to another Conn, in some type \textit{m}
  \item The \textit{m} was usually an Applicative or a Monad
  \item A type synonym for a regular function
  \item This signature might remind you of Bind
    }
\end{frame}

\begin{frame}
  \frametitle{Middleware (Old Design)}
  \lstinputlisting[language=purescript]{src/listings/Kleisli.purs}
  \notelist{
  \item Middleware could therefore be composed using regular Kleisli composition
  \item Here we see three middleware, composed from left to right
  \item The connection goes into the first one, it gives back a new one, goes into the second, and so on
  \item All good? Not really.
    }
\end{frame}

\begin{frame}
  \frametitle{Whoops, Not Safe}
  \lstinputlisting[language=purescript]{src/listings/MiddlewareOldUnsafe.purs}
  \notelist{
  \item We define a middleware called \textit{badMiddleware}
  \item It takes a conn and passes it to the first respond middleware
  \item It ignores that resulting conn, passes the argument again
  \item Had we passed the result, or used Kleisli, we would have a type error
  \item The problem: Our safety is in the Conn values, and we can discard them
  \item The solution: The monad has to carry the Conn type
    }
\end{frame}

\begin{frame}
  \frametitle{Middleware (Revised)}
  \lstinputlisting[language=purescript]{src/listings/Middleware.purs}
  \notelist{
  \item The new middleware is an indexed monad
  \item Works as a state monad, with state type changes in its parameters
  \item You cannot run an effectful middleware without the types matching
  \item Let's see how this can solve the double-respond problem from before
  \item We will begin by looking at Response State Transitions
    }
\end{frame}

\begin{frame}
  \frametitle{Response State Transitions}
  \begin{itemize}
    \pause
    \item<+-> Hyper tracks the state of response writing
    \item<+-> Guarantees correctness in response side effects
    \item<+-> Abstractions can be built on top safely
    \item<+-> Response-writing middleware can be backend-agnostic
  \end{itemize}
  \notelist {
    \item Hyper tracks the state of response writing
    \item Guarantees correctness in response side effects, preventing common programming errors
    \item Abstractions can be built on top safely
    \item Response-writing middleware can be backend-agnostic
  }
\end{frame}


\begin{frame}
  \frametitle{ResponseStateTransition}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/ResponseStateTransition.purs}
  \notelist{
  \item This is a helper type alias
  \item A transition is a Middleware
  \item Takes Conn with Response writer in the \textbf{from} state
  \item Transforms it to a Conn with Response writer in the \textbf{to} state
    }
\end{frame}

\begin{frame}[fragile]
  \frametitle{ResponseWriter}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/ResponseWriter.purs}
  \notelist{
  \item ResponseWriter encodes the possible state transitions
	\item Go through them one by one
    }
\end{frame}

\begin{frame}[fragile]
  \frametitle{What if we do it wrong?}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/error.purs}
  \notelist{
  \item And if we write responses incorrectly, we get a compile-time error
  \item With this safety, we can without fear build new things on top
    }
\end{frame}

\begin{frame}
  \frametitle{Writing Headers}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/headers.purs}
  \notelist{
  \item The \textit{headers} function is a minimal example of abstraction
  \item It writes all specified headers, then closes headers
  \item The implementation? Pretty simple.
  \item Now for a much higher-level abstraction on top of Hyper, namely \textit{type-level routing}
    }
\end{frame}

\begin{frame}
  \singletitle{Type-Level Routing}
  \notelist{
  \item This is very much inspired by Servant, for Haskell
  \item I can really recommend Servant
  \item This version for Hyper, being written in PureScript, has some benefits
  \item I'll get to that later
  }
\end{frame}

\begin{frame}
  \frametitle{A Routing Type}
  \lstinputlisting[language=purescript]{src/listings/Site1.purs}
  \notelist{
  \item We first define a resource data type
  \item Then we define a routing type
  \item Note that the routing type has no value-level representation defined
    }
\end{frame}

\begin{frame}
  \frametitle{Handler}
  \lstinputlisting[language=purescript]{src/listings/Site1-handler.purs}
  \notelist{
  \item We also need a handler
  \item The handler is a function applied when a route is matched
  \item It returns a response for a request
  \item Argument types and return type can be our custom data types
  \item But how does one respond with HTML, or JSON
    }
\end{frame}

\begin{frame}
  \frametitle{HTMLEncode}
  \lstinputlisting[language=purescript]{src/listings/Site1-encode.purs}
  \notelist{
  \item We need an instance of MimeEncoder
  \item By defining an instance for EncodeHTML, we get the MimeEncoder automatically
  \item Hyper includes a small HTML DSL for now
  \item It will probably use an existing one called \textit{smolder} instead
  \item Remember how our routing type had no value-level representation?
  \item We need to pass it to the router, but how?
    }
\end{frame}

\begin{frame}
  \frametitle{Proxy}
  \begin{center}
  The Proxy type and values are for situations where type information is
  required for an input to determine the type of an output, but where it is not
  possible or convenient to provide a value for the input.
  \end{center}
  \notelist{
  \item We use the PureScript Proxy type
  }
\end{frame}

\begin{frame}
  \frametitle{Site Proxy}
  \lstinputlisting[language=purescript]{src/listings/Site1-proxy.purs}
  \notelist{
  \item Here we create a proxy for our routing type
    }
\end{frame}

\begin{frame}
  \frametitle{Site Router}
  \lstinputlisting[language=purescript]{src/listings/Site1-router.purs}
  \notelist{
  \item We define an HTTP error handler
  \item And our router, by passing the proxy and our home handler
    }
\end{frame}

\begin{frame}
  \frametitle{Main Entrypoint}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/Site1-main.purs}
  \notelist{
  \item Lastly, we define our main function that starts the server
    }
\end{frame}

\begin{frame}
  \singletitle{More Routes!}
  \notelist{
  \item Having only one route seems lame. Let's add some more
    }
\end{frame}

\begin{frame}
  \frametitle{Multiple Endpoints with Captures}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/Site2.purs}
  \notelist{
  \item (explain code)
    }
\end{frame}

\begin{frame}
  \frametitle{Multiple Handlers}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/Site2-handler.purs}
  \notelist{
  \item Our home handler looks like before
  \item allUsers is simply wrapping the array of user values
  \item getUser performs a lookup, possibly throws Not Found error
  \item Now that we have multiple routes, how do we link between them?
    }
\end{frame}

\begin{frame}
  \frametitle{Type-Safe Links}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/Site2-links.purs}
  \notelist{
  \item In our HTML encoder, we want to produce anchor tags
  \item As we have routing types, we get type-safe links for free
    }
\end{frame}

\begin{frame}
  \frametitle{Multiple Endpoint Router}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/Site2-router.purs}
  \notelist{
  \item We combine our handlers with a structure matching the routing type
	\item Matching the type incorrectly would result in a type error
	\item OK, so that is nice.
  \item But I talked about progressive enhancement before? How about that?
    }
\end{frame}

\begin{frame}
  \singletitle{Automatically Derived XHR Clients}
  \notelist{
  \item Instead of sprinkling Javascript or jQuery scripts all over the place
  \item with no type safety or guarantees they are in sync with routes
  \item Let's automatically dervice safe XHR clients
    }
\end{frame}

\begin{frame}
  \frametitle{Shared Routing Type}
  \lstinputlisting[language=purescript]{src/listings/XHR-task.purs}
  \notelist{
  \item We define a type Task
    }
\end{frame}

\begin{frame}
  \frametitle{Shared Routing Type}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/XHR-instances.purs}
  \notelist{
	\item Provide some encoding and decoding instances for JSON
    }
\end{frame}

\begin{frame}
  \frametitle{Shared Routing Type}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/XHR-site.purs}
  \notelist{
	\item Define the routing type
	\item and our Proxy value
	\item We write our handlers and a server just like before
	\item Finally, we use it in a client-side application
    }
\end{frame}

\begin{frame}
  \frametitle{Shared Routing Type}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/XHR-client.purs}
  \notelist{
	\item This is a snippet from a PureScript Pux app
	\item The code in bold is where we generate AJAX clients for our site
  \item We pattern match on the structure to get a specific client
	\item I think this is a very strong case for Hyper
    }
\end{frame}

\begin{frame}
  \frametitle{Other Possibilites/Future Work}
  \begin{itemize}
    \pause
    \item<+-> Type-safe forms
    \item<+-> PJAX, but with JSON data and client-side templates
    \item<+-> Mocked servers and clients using \lstinline{Arbitrary} instances
    \item<+-> Ring-like response map abstraction
    \item<+-> Other backends
    \item<+-> Continue to Quest For Type-Safe Web!
  \end{itemize}
  \notelist{
  \item So, what more can we do here?
  \item I'd like type safe form posts
	\item PJAX, the hyper way
	\item Mocked servers with Arbitrary
	\item Ring-like abstraction for response maps
	\item Other backends
	\item And in general, continue the quest for type-safe web!
    }
\end{frame}

\begin{frame}
  \singletitle{Summary}
  \notelist{
  \item Server-side or SPA is not have to be a binary choice
  \item We can make the middleground much nicer, building better tools
  \item Good programming languages and type systems are our allies
    }
\end{frame}

\begin{frame}
  \singletitle{Thank You!}
  \notelist{
  \item Thank you
  \item Here are some links to things I've mentioned...
    }
\end{frame}

\begin{frame}[allowframebreaks]
	\frametitle{Useful References}
  \nocite{*}
	\printbibliography
\end{frame}

\begin{frame}
  \titlepage
  \notelist{
  \item Questions?
    }
\end{frame}
