\begin{frame}
  \titlepage
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Me}
  \begin{itemize}
    \pause
    \item<+-> Started out in music
    \item<+-> Found PHP around 2011, then saved by FP soon after
    \item<+-> Programming languages and compilers in free time
    \item<+-> Worked on the Oden language last year
    \item<+-> Currently building CodeScene at work, mostly in Clojure
    \item<+-> Building Hyper in free time
  \end{itemize}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Agenda}
  \begin{itemize}
    \pause
    \item<+-> Functional Programming, Type Systems, and Web Applications
    \item<+-> What about Server-Side Rendering?
    \item<+-> Web Servers, Functional Programming, and Static Typing
    \item<+-> Hyper
  \end{itemize}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \singletitle{Functional Programming, Type Systems, and Web Applications}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Single-Page Applications}
  \begin{itemize}
    \pause
    \item<+-> Work more like desktop applications
    \item<+-> There are \textbf{a lot} of these frameworks in JS
    \item<+-> Angular, Ember, Meteor, React (with friends)
    \item<+-> Without Javascript, you get nothing
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Functional Programming Influence}
  \begin{itemize}
    \pause
    \item<+-> FP influences Javascript
    \item<+-> ECMAScript 6 has higher-order functions, arrow function syntax
    \item<+-> Libraries like Underscore, Rambda, Fantasy Land
    \item<+-> React is functional at its core
    \item<+-> Functional Reactive Programming (FRP)
    \item<+-> Javascript as a compile target for FP languages
    \item<+-> Still, main focus is single-page apps
  \end{itemize}
\end{frame}

\begin{frame}
  \singletitle{What about Server-Side Rendering?}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Server-Side Rendering}
  \begin{itemize}
    \pause
    \item<+-> Progressive Enhancement
    \item<+-> Using what's already in the browser
    \item<+-> The client-server state machine, and "isomorphic" web apps
    \item<+-> PJAX
    \item<+-> If it's a tooling problem, let's build tools!
  \end{itemize}
\end{frame}

\begin{frame}
  \singletitle{Web Servers, Functional Programming, and Static Typing}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Web Servers, Functional Programming, and Static Typing}
  \begin{itemize}
    \pause
    \item<+-> Dynamic languages in web server programming
    \item<+-> Compile-time guarantees
    \item<+-> Safely abstract and compose
    \item<+-> Maintainable code
    \item<+-> Developer experience, incentivize not doing SPA
  \end{itemize}
  \notelist{
  \item We have seen a lot of dynamically typed languages in web development
  \item When programs grow big, and teams grow big, static typing is our friend
  \item We should be able to safely build abstractions and compose things
  \item Be confident that the pieces work together
	\item We should be able to maintain code, refactor it, change it, delete it
  \item Again, I think we need a good developer experience
  }
\end{frame}

\begin{frame}
  \frametitle{Things I've Found}
  \begin{itemize}
    \pause
    \item<+-> Haskell:
      \begin{itemize}
        \item<+-> Yesod
        \item<+-> Servant
      \end{itemize}
    \item<+-> Scala:
      \begin{itemize}
        \item<+-> Play
        \item<+-> Rho
      \end{itemize}
    \item<+-> PureScript:
      \begin{itemize}
        \item<+-> purescript-express
      \end{itemize}
  \end{itemize}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Statically Typed Middleware}
  \begin{itemize}
    \pause
    \item<+-> Middleware is a common abstraction
    \item<+-> Very easy to mess up if dynamically typed
      \begin{itemize}
        \item<+-> Incorrect ordering
        \item<+-> Incomplete responses
        \item<+-> Overwriting headers
        \item<+-> Writing multiple responses
        \item<+-> Consuming non-parsed, or badly parsed, request body
        \item<+-> Missing authentication and/or authorization
      \end{itemize}
    \item<+-> Idea: use extensible records in PureScript!
  \end{itemize}
\end{frame}


%
% HYPER
%


\begin{frame}
  \begin{center}
    \vfill\vfill
    \includegraphics[width=0.5\textwidth]{src/graphics/hyper.png}\\
    \vspace{1em}
    \fontsize{20pt}{20pt}{Type-safe, statically checked composition of HTTP servers}
    \vfill\vfill
  \end{center}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Goals}
  \begin{itemize}
    \pause
    \item<+-> A safe HTTP middleware architecture
    \item<+-> Make the effects of applying middleware explicit in types
    \item<+-> Ensure correct composition of middleware and application components
    \item<+-> Interoperability with NodeJS and other backends (purerl, purescript-native)
    \item<+-> No magic
  \end{itemize}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{How?}
  \begin{itemize}
    \pause
    \item<+-> Track middleware effects in type system (not only side-effects!)
    \item<+-> Leverage extensible records in PureScript
    \item<+-> Provide a common API for middleware
    \item<+-> Write backend-agnostic middleware where possible
    \item<+-> Integrate with existing NodeJS libraries
  \end{itemize}
\end{frame}

\begin{frame}
  \singletitle{Design}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Conn}
  \lstinputlisting[language=purescript]{src/listings/Conn.purs}
  \notelist{
  \item Conn, short for Connection
  \item Models the entirety of an HTTP connection
  \item Design adapted from Plug in Elixir
    }
\end{frame}


\begin{frame}
  \frametitle{Middleware (Old Design)}
  \lstinputlisting[language=purescript]{src/listings/MiddlewareOld.purs}
  \notelist{
  \item A function transformed a Conn to another Conn, in some type \textit{m}
  \item A type synonym for a regular function
  \item The \textit{m} could be any Applicative or Monad
  \item This signature might remind you of Bind
    }
\end{frame}

\begin{frame}
  \frametitle{Middleware (Old Design)}
  \lstinputlisting[language=purescript]{src/listings/Kleisli.purs}
  \notelist{
  \item Middleware could therefore be composed using regular Kleisli composition
  \item Here we see three middleware, composed from left to right
    }
\end{frame}

\begin{frame}
  \frametitle{Whoops, Not Safe}
  \lstinputlisting[language=purescript]{src/listings/MiddlewareOldUnsafe.purs}
  \notelist{
  \item We define a middleware called \textit{badMiddleware}
  \item It takes a conn and passes it to the first respond middleware
  \item It ignores that resulting conn, passes the argument again
  \item Had we passed the result, or used Kleisli, we would have a type error
  \item The problem: Our safety is in the Conn values, and we can discard them
  \item The solution: The monad has to carry the Conn type
    }
\end{frame}

\begin{frame}
  \frametitle{Middleware (Revised)}
  \lstinputlisting[language=purescript]{src/listings/Middleware.purs}
  \notelist{
  \item The new middleware is an indexed monad
  \item Works as a state monad, with state type changes in its parameters
  \item You cannot run an effectful middleware without the types matching
  \item Let's see how this solves the double-end problem from before
    }
\end{frame}

\begin{frame}
  \frametitle{Response State Transitions}
  \begin{itemize}
    \pause
    \item<+-> Hyper tracks the state of response writing
    \item<+-> Guarantees correctness in response handling, preventing common programming errors
    \item<+-> Abstractions can be built on top safely
    \item<+-> Response-writing middleware can be backend-agnostic
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{ResponseStateTransition}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/ResponseStateTransition.purs}
  \notelist{
  \item We start by looking at this helper type alias
  \item A transition is a Middleware
  \item Takes Conn with Response writer in the \textbf{from} state
  \item Returns Conn with Response writer in the \textbf{to} state
    }
\end{frame}

\begin{frame}[fragile]
  \frametitle{ResponseWriter}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/ResponseWriter.purs}
  \notelist{
  \item ResponseWriter encodes the possible state transitions
    }
\end{frame}

\begin{frame}
  \frametitle{Writing Headers}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/headers.purs}
  \notelist{
  \item The \textit{headers} function is a minimal example of abstraction
  \item It writes all specified headers, then closes headers
  \item The implementation? Pretty simple.
  \item Now for a much higher-level abstraction on top of Hyper, namely \textit{type-level routing}
    }
\end{frame}

\begin{frame}
  \singletitle{Type-Level Routing}
  \notelist{
  \item This is very much inspired by Servant, for Haskell
  \item I can really recommend Servant
  \item This version for Hyper, being written in PureScript, has some benefits
  \item I'll get to that later
  }
\end{frame}

\begin{frame}
  \frametitle{A Routing Type}
  \lstinputlisting[language=purescript]{src/listings/Site1.purs}
  \notelist{
  \item We first define a resource data type
  \item Then we define a routing type
  \item Note that the routing type has no value-level representation defined
    }
\end{frame}

\begin{frame}
  \frametitle{Handler}
  \lstinputlisting[language=purescript]{src/listings/Site1-handler.purs}
  \notelist{
  \item We also need a handler
  \item The handler is a function applied when a route is matched
  \item It returns a response for a request
  \item Argument types and return type can be our custom data types
  \item But how does one respond with HTML, or JSON
    }
\end{frame}

\begin{frame}
  \frametitle{HTMLEncode}
  \lstinputlisting[language=purescript]{src/listings/Site1-encode.purs}
  \notelist{
  \item We need an instance of MimeEncoder
  \item By defining an instance for EncodeHTML, we get the MimeEncoder automatically
  \item Hyper includes a small HTML DSL for now
  \item It will probably use an existing one called \textit{smolder} instead
  \item Remember how our routing type had no value-level representation?
  \item We need to pass it to the router, but how?
    }
\end{frame}

\begin{frame}
  \frametitle{Proxy}
  \begin{center}
  The Proxy type and values are for situations where type information is
  required for an input to determine the type of an output, but where it is not
  possible or convenient to provide a value for the input.
  \end{center}
  \notelist{
  \item We use the PureScript Proxy type
  }
\end{frame}

\begin{frame}
  \frametitle{Site Proxy}
  \lstinputlisting[language=purescript]{src/listings/Site1-proxy.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Site Router}
  \lstinputlisting[language=purescript]{src/listings/Site1-router.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Main Entrypoint}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/Site1-main.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \singletitle{More Routes!}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Multiple Endpoints with Captures}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/Site2.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Multiple Handlers}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/Site2-handler.purs}
  \notelist{
  \item Our home handler looks like before
  \item allUsers is simply wrapping the array of user values
  \item getUser performs a lookup, possibly throws Not Found error
  \item Now that we have multiple routes, how do we link between them?
    }
\end{frame}

\begin{frame}
  \frametitle{Type-Safe Links}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/Site2-links.purs}
  \notelist{
  \item In our HTML encoder, we want to produce anchor tags
  \item As we have routing types, we get type-safe links for free
    }
\end{frame}

\begin{frame}
  \frametitle{Multiple Endpoint Router}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/Site2-router.purs}
  \notelist{
  \item We combine our handlers with a structure matching the routing type
	\item Matching the type incorrectly would result in a type error
	\item OK, so that is nice. Can we take this further?
    }
\end{frame}

\begin{frame}
  \singletitle{Automatically Derived XHR Clients}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Shared Routing Type}
  \lstinputlisting[language=purescript]{src/listings/XHR-task.purs}
  \notelist{
  \item We define a type Task
    }
\end{frame}

\begin{frame}
  \frametitle{Shared Routing Type}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/XHR-instances.purs}
  \notelist{
	\item Provide some encoding and decoding instances for JSON
    }
\end{frame}

\begin{frame}
  \frametitle{Shared Routing Type}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/XHR-site.purs}
  \notelist{
	\item Define the routing type
	\item and our Proxy value
	\item Finally, we use it in a client-side application
    }
\end{frame}

\begin{frame}
  \frametitle{Shared Routing Type}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/XHR-client.purs}
  \notelist{
	\item This is a snippet from a PureScript Pux app
	\item The code in bold is where we generate AJAX clients for our site
  \item We pattern match on the structure to get a specific client
	\item I think this is a very strong case for Hyper
    }
\end{frame}

\begin{frame}
  \frametitle{Other Possibilites/Future Work}
  \begin{itemize}
    \pause
    \item<+-> Type-safe forms
    \item<+-> PJAX, but with JSON data and client-side templates
    \item<+-> Mocked servers and clients using \lstinline{Arbitrary} instances
    \item<+-> Ring-like response map abstraction
    \item<+-> Other backends
    \item<+-> Continue to Quest For Type-Safe Web!
  \end{itemize}
  \notelist{
  \item So, what more can we do here?
  \item I'd like type safe form posts, both JSON and HTML
	\item
    }
\end{frame}

\begin{frame}
  \singletitle{Summary}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}[allowframebreaks]
	\frametitle{Useful References}
  \nocite{*}
	\printbibliography
\end{frame}

\begin{frame}
  \singletitle{Thank You}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \titlepage
  \notelist{
  \item TODO
    }
\end{frame}
