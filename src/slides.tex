\begin{frame}
  \titlepage
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Me}
  \begin{itemize}
    \pause
    \item<+-> Started out in music
    \item<+-> Found PHP around 2011, then saved by FP soon after
    \item<+-> Programming languages and compilers in free time
    \item<+-> Worked on the Oden language last year
    \item<+-> Currently building CodeScene at work, mostly in Clojure
    \item<+-> Building Hyper in free time
  \end{itemize}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Agenda}
  \begin{itemize}
    \pause
    \item<+-> Functional Programming, Type Systems, and Web Applications
    \item<+-> What about Server-Side Rendering?
    \item<+-> Web Servers, Functional Programming, and Static Typing
    \item<+-> Hyper
  \end{itemize}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \singletitle{Functional Programming, Type Systems, and Web Applications}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Single-Page Applications}
  \begin{itemize}
    \pause
    \item<+-> Work more like desktop applications
    \item<+-> There are \textbf{a lot} of these frameworks in JS
    \item<+-> Angular, Ember, Meteor, React (with friends)
    \item<+-> Without Javascript, you get nothing
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Functional Programming Influence}
  \begin{itemize}
    \pause
    \item<+-> FP influences Javascript
    \item<+-> ECMAScript 6 has higher-order functions, arrow function syntax
    \item<+-> Libraries like Underscore, Rambda, Fantasy Land
    \item<+-> React is functional at its core
    \item<+-> Functional Reactive Programming (FRP)
    \item<+-> Javascript as a compile target for FP languages
    \item<+-> Still, main focus is single-page apps
  \end{itemize}
\end{frame}

\begin{frame}
  \singletitle{What about Server-Side Rendering?}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Server-Side Rendering}
  \begin{itemize}
    \pause
    \item<+-> Progressive Enhancement
    \item<+-> Using what's already in the browser
    \item<+-> The client-server state machine, and "isomorphic" web apps
    \item<+-> PJAX
    \item<+-> If it's a tooling problem, let's build tools!
  \end{itemize}
\end{frame}

\begin{frame}
  \singletitle{Web Servers, Functional Programming, and Static Typing}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Web Servers, Functional Programming, and Static Typing}
  \begin{itemize}
    \pause
    \item<+-> Dynamic languages in web server programming
    \item<+-> Compile-time guarantees
    \item<+-> Safely abstract and compose
    \item<+-> Maintainable code
    \item<+-> Developer experience, incentivize not doing SPA
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Things I've Found}
  \begin{itemize}
    \pause
    \item<+-> Haskell:
      \begin{itemize}
        \item<+-> Happstack
        \item<+-> Yesod
        \item<+-> Servant
      \end{itemize}
    \item<+-> Scala:
      \begin{itemize}
        \item<+-> Play
        \item<+-> Lift
        \item<+-> Rho
      \end{itemize}
    \item<+-> PureScript:
      \begin{itemize}
        \item<+-> purescript-express
      \end{itemize}
  \end{itemize}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Statically Typed Middleware}
  \begin{itemize}
    \pause
    \item<+-> Middleware is a common abstraction
    \item<+-> Very easy to mess up if dynamically typed
      \begin{itemize}
        \item<+-> Incorrect ordering
        \item<+-> Incomplete responses
        \item<+-> Overwriting headers
        \item<+-> Writing multiple responses
        \item<+-> Consuming non-parsed, or badly parsed, request body
        \item<+-> Missing authentication and/or authorization
      \end{itemize}
    \item<+-> Idea: use extensible records in PureScript!
  \end{itemize}
\end{frame}


%
% HYPER
%


\begin{frame}
  \begin{center}
    \vfill\vfill
    \includegraphics[width=0.5\textwidth]{src/graphics/hyper.png}\\
    \vspace{1em}
    \fontsize{20pt}{20pt}{Type-safe, statically checked composition of HTTP servers}
    \vfill\vfill
  \end{center}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Goals}
  \begin{itemize}
    \pause
    \item<+-> A safe HTTP middleware architecture
    \item<+-> Make the effects of applying middleware explicit in types
    \item<+-> Ensure correct composition of middleware and application components
    \item<+-> Interoperability with NodeJS and other backends (purerl, purescript-native)
    \item<+-> No magic
  \end{itemize}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{How?}
  \begin{itemize}
    \pause
    \item<+-> Track middleware effects in type system (not only side-effects!)
    \item<+-> Leverage extensible records in PureScript
    \item<+-> Provide a common API for middleware
    \item<+-> Write backend-agnostic middleware where possible
    \item<+-> Integrate with existing NodeJS libraries
  \end{itemize}
\end{frame}

\begin{frame}
  \singletitle{Design}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{Conn}
  \lstinputlisting[language=purescript]{src/listings/Conn.purs}
  \notelist{
  \item Conn, short for Connection
  \item Models the entirety of an HTTP connection
  \item Design adapted from Plug in Elixir
    }
\end{frame}


\begin{frame}
  \frametitle{Middleware (Old Design)}
  \lstinputlisting[language=purescript]{src/listings/MiddlewareOld.purs}
  \notelist{
  \item A function transformed a Conn to another Conn, in some type \textit{m}
  \item A type synonym for a regular function
  \item The \textit{m} could be any Applicative or Monad
  \item This signature might remind you of Bind
    }
\end{frame}

\begin{frame}
  \frametitle{Middleware (Old Design)}
  \lstinputlisting[language=purescript]{src/listings/Kleisli.purs}
  \notelist{
  \item Middleware could therefore be composed using regular Kleisli composition
  \item Here we see three middleware, composed from left to right
    }
\end{frame}

\begin{frame}
  \frametitle{Whoops, Not Safe}
  \lstinputlisting[language=purescript]{src/listings/MiddlewareOldUnsafe.purs}
  \notelist{
  \item We define a middleware called \textit{badMiddleware}
  \item It takes a conn and passes it to the first respond middleware
  \item It ignores that resulting conn, passes the argument again
  \item Had we passed the result, or used Kleisli, we would have a type error
  \item The problem: Our safety is in the Conn values, and we can discard them
  \item The solution: The monad has to carry the Conn type
    }
\end{frame}

\begin{frame}
  \frametitle{Middleware (Revised)}
  \lstinputlisting[language=purescript]{src/listings/Middleware.purs}
  \notelist{
  \item The new middleware is an indexed monad
  \item Works as a state monad, with state type changes in its parameters
  \item You cannot run an effectful middleware without the types matching
  \item Let's see how this solves the double-end problem from before
    }
\end{frame}

\begin{frame}
  \frametitle{Response State Transitions}
  \begin{itemize}
    \pause
    \item<+-> Hyper tracks the state of response writing
    \item<+-> Guarantees correctness in response handling, preventing common programming errors
    \item<+-> Abstractions can be built on top safely
    \item<+-> Response-writing middleware can be backend-agnostic
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{ResponseStateTransition}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/ResponseStateTransition.purs}
  \notelist{
  \item We start by looking at this helper type alias
  \item A transition is a Middleware
  \item Takes Conn with Response writer in the \textbf{from} state
  \item Returns Conn with Response writer in the \textbf{to} state
    }
\end{frame}

\begin{frame}[fragile]
  \frametitle{ResponseWriter}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/ResponseWriter.purs}
  \notelist{
  \item ResponseWriter encodes the possible state transitions
    }
\end{frame}

\begin{frame}
  \frametitle{Writing Headers}
  \lstinputlisting[language=purescript,style=medium-size]{src/listings/headers.purs}
  \notelist{
  \item The \textit{headers} function is a minimal example of abstraction
  \item It writes all specified headers, then closes headers
  \item The implementation? Pretty simple.
    }
\end{frame}

\begin{frame}
  \singletitle{Type-Level Routing}
  \notelist{
  \item TODO
  }
\end{frame}

\begin{frame}
  \frametitle{A Routing Type}
  \lstinputlisting[language=purescript]{src/listings/Site1.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Handler}
  \lstinputlisting[language=purescript]{src/listings/Site1-handler.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{HTMLEncode}
  \lstinputlisting[language=purescript]{src/listings/Site1-encode.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Proxy}
  \textit{
  The Proxy type and values are for situations where type information is
  required for an input to determine the type of an output, but where it is not
  possible or convenient to provide a value for the input.}
\end{frame}

\begin{frame}
  \frametitle{Site Proxy}
  \lstinputlisting[language=purescript]{src/listings/Site1-proxy.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Site Router}
  \lstinputlisting[language=purescript]{src/listings/Site1-router.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Site Router}
  \lstinputlisting[language=purescript,style=smaller-size]{src/listings/Site1-main.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \singletitle{More Routes!}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Multiple Endpoints with Captures}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/Site2.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Multiple Handlers}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/Site2-handler.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Multiple Endpoint Router}
  \lstinputlisting[language=purescript,style=small-size]{src/listings/Site2-router.purs}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \singletitle{Automatically Derived XHR Clients}
  \notelist{
  \item TODO
    }
\end{frame}


\begin{frame}
  \singletitle{Summary}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \frametitle{Summary}
  \begin{itemize}
    \item TODO
  \end{itemize}
\end{frame}

\begin{frame}
  \singletitle{Thank You}
  \notelist{
  \item TODO
    }
\end{frame}

\begin{frame}
  \titlepage
  \notelist{
  \item TODO
    }
\end{frame}
